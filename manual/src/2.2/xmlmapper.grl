#sc1 xmlmapper_intro XML to Object Mapper #sc1

#par Since version 2.0 Spicelib contains a small but powerful and flexibel XML-to-Object Mapper.
It allows you to map from XML to AS3 classes - in both directions. It comes with builtin mappers
which cover the most common use cases like mapping properties of AS3 classes to XML attributes
or child elements. But it is easily extensible to add your custom mappers for some of your XML
elements and combine them with the builtin ones. #par



#sc2 xmlmapper_example Usage Example #sc2 

#par Let's start with a simple example. Consider this XML structure: #par

#cdb
<order>
    <book 
        isbn="0942407296" 
        page-count="256"
        title="Rain"
        author="Karen Duve"
    />
    <book 
        isbn="0953892201" 
        page-count="272"
        title="Perfume"
        author="Patrick Suskind"
        comment="Special Offer"
    />    
</order>
#cdb

#par Now we create two classes that this XML structure should map to: #par

#cdb
public class Order {

    public var books:Array;
    
}
#cdb

#cdb
public class Book {

    [Required]
    public var isbn:String;
    
    [Required]
    public var pageCount:int;
    
    [Required]
    public var title:String;
    
    [Required]
    public var author:String;
    
    public var comment:String;
    
}
#cdb

#par It should be obvious how XML elements and attributes are supposed to map to these two classes and their properties.
The only detail that probably needs a bit of explanation is the #cdi [Required] #cdi metadata tag. The mapper validates
the XML based on these annotations. So for the #cdi book #cdi element only the #cdi comment #cdi attribute is optional.
If any of the other 4 attributes would be missing the mapping operation will fail. For more details see 
#ref xmlmapper_validation #ref. #par

#par Next we create the mapper that is responsible for transforming this structure; #par

#cdb
var bookBuilder:PropertyMapperBuilder = new PropertyMapperBuilder(Book, new QName("book"));
bookBuilder.mapAllToAttributes();

var orderBuilder:PropertyMapperBuilder = new PropertyMapperBuilder(Order, new QName("order"));
orderBuilder.mapToChildElement("books", bookBuilder.build());

var mapper:XmlObjectMapper = orderBuilder.build();
#cdb

#par First we create the #cdi PropertyMapperBuilder #cdi for the #cdi book #cdi tag.
We pass the class the element should be mapped to as an #cdi ClassInfo #cdi instance (#cdi ClassInfo #cdi
is part of the Spicelib Reflection API) and the name of the XML element.
With the call to #cdi mapAllToAttributes #cdi we simply instruct the builder to map all properties
of the #cdi Book #cdi class to attributes of the #cdi book #cdi XML element. This includes processing
the #cdi [Required] #cdi tags we already mentioned as well as type conversions (if necessary). #par

#par We then create the builder for the #cdi order #cdi tag in a similar way. This time we don't want
properties to map to attributes but to child elements. We get this behaviour through this line: #par

#cdb
orderBuilder.mapToChildElement("books", bookBuilder.build());
#cdb

#par This instructs the framework to map child elements to the #cdi books #cdi Array property.
It will use the mapper returned by #cdi bookBuilder.build() #cdi for mapping the child elements
itself. This way you can build possibly large and complex hierarchies of mappers where each mapper
is only responsible for a single tag. #par

#par The fact that the #cdi books #cdi property is of type Array has an influence on the validator:
It will allow multiple child elements. Otherwise it would allow at most a single child element of that type. #par

#par The mapper we created is now ready to use. This is how we would map from XML to objects: #par

#cdb
var xml:XML = ...;
var context:XmlProcessorContext = new XmlProcessorContext();
var order:Order = mapper.mapToObject(xml, context) as Order;
#cdb

#par And this is how we'd map from objects to XML: #par

#cdb
var order:Order = ...;
var context:XmlProcessorContext = new XmlProcessorContext();
var xml:XML = mapper.mapToXml(order, context);
#cdb


#sc2 xmlmapper_example The PropertyMapperBuilder #sc2

#par The #cdi PropertyMapperBuilder #cdi class we already introduced in our example is the main entry
point for building mappers. In theory you create your own implementations of the #cdi XmlObjectMapper #cdi 
interface from scratch. But in most cases the mapping logic would involve mapping properties of classes
to XML nodes (elements, attributes or text nodes), and for these most common use cases the #cdi PropertyMapperBuilder #cdi
is the most convenient option. #par

#par Like in the example in the previous section you always create an instance of this class passing
the AS3 class and the XML element name that should be mapped to the constructor. You then call one or more
of the #cdi mapXXX #cdi methods to give detailed instructions on how to map the properties of the specified
class. Finally you create the actual mapper with #cdi PropertyMapperBuilder.build() #cdi, possibly using
it as the mapper for child elements of another mapper. #par

#par In the following sections we describe the exact behaviour of the various #cdi mapXXX #cdi methods.
But first we'll provide some more detail on the validation process. #par



#sc2 xmlmapper_validation Validation #sc2

#par Like shown in the simple example you can place #cdi [Required] #cdi metadata on properties so that the
mapper throws an Error if the attribute or child element that the property is mapped to is not present in XML.
This section provides some more detail on the exact semantics of this feature. #par

#sub Validating single valued properties #sub

#par When a property is single valued, either with a simple type that maps to an attribute or a text node
or typed to a class that maps to a child element, the validation process includes the following checks: #par

#lst
#lse If the property is marked with the #cdi [Required] #cdi tag the mapper checks if the attribute, text node
or child element is present in the mapped XML and throws an error if it is missing. Without the metadata tag
the mapped XML element is considered optional. #lse

#lse If the single valued property is mapped to a child element the mapper validates that there is at most
a single occurence of that element and throws an Error if otherwise. #lse
#lst

#sub Validating Array properties #sub

#par Array properties cannot be mapped to attributes (as multiple occurences of the same attribute in a single
element are not possible). If they are mapped to child text nodes or child elements, the validation process
includes the following checks: #par

#lst
#lse If the property is marked with the #cdi [Required] #cdi tag the mapper checks if the child text node
or child element has at least a single occurence and throws an Error if otherwise. #lse

#lse Without the #cdi [Required] #cdi tag any number of occurences for the child element (including 0)
are permitted. #lse
#lst 



#sc2 xmlmapper_attributes Mapping Attributes #sc2

#par Properties with a simple type like #cdi String #cdi, #cdi int #cdi, #cdi Boolean #cdi, #cdi Class #cdi or #cdi Date #cdi
can be mapped to attributes: #par

#cdb
public class Song {

    public var year:int;
    public var title:String;
    public var artist:String;
    
}
#cdb

#cdb
<song
    year="1989" 
    title="Monkey Gone To Heaven"
    artist="Pixies"
/>
#cdb

#par The PropertyMapperBuilder class contains two methods that let you instruct the mapper to map to attributes: #par

#cdb
public function mapAllToAttributes () : void

public function mapToAttribute (propertyName:String, attributeName:QName = null) : void
#cdb

#par The first method was already used in our usage example: It instructs the mapper to map all properties of the mapped
class to attributes in XML. This is a convenient short cut which you'll probably use in a lot of use cases. This method
can be combined with other methods of the #cdi PropertyMapperBuilder #cdi class. If you invoke it after you already
explicitly mapped some of the properties of a class, it will just map all remaining properties to attributes. #par

#par The second method let's you specify a mapping for a single property. You have to specify the name of the
property and optionally the name of the XML attribute. If you omit the second parameter the attribute name
will be the same as the property name (but camel-case notation transformed to dash-based notation, e.g.
#cdi pageCount #cdi to #cdi page-count #cdi. #par



#sc2 xmlmapper_childtextnodes Mapping Child Text Nodes #sc2

#par Properties with a simple type like #cdi String #cdi, #cdi int #cdi, #cdi Boolean #cdi, #cdi Class #cdi or #cdi Date #cdi
can also be mapped to child text nodes, a mechanism very similar to mapping to attributes: #par

#cdb
public class Song {

    public var year:int;
    public var title:String;
    public var artist:String;
    
}
#cdb

#cdb
<song>
    <year>1989</year> 
    <title>Monkey Gone To Heaven</title>
    <artist>Pixies</artist>
</song>
#cdb

#par The PropertyMapperBuilder class contains two methods that let you instruct the mapper to map to child text nodes: #par

#cdb
public function mapAllToChildTextNodes () : void

public function mapToChildTextNode (propertyName:String, childName:QName = null) : void
#cdb

#par The first method instructs the mapper to map all properties of the mapped
class to child text nodes in XML. This method
can be combined with other methods of the #cdi PropertyMapperBuilder #cdi class. If you invoke it after you already
explicitly mapped some of the properties of a class, it will just map all remaining properties to child text nodes. #par

#par The second method let's you specify a mapping for a single property. You have to specify the name of the
property and optionally the name of the XML child element. If you omit the second parameter the child element name
will be the same as the property name (but camel-case notation transformed to dash-based notation, e.g.
#cdi pageCount #cdi to #cdi page-count #cdi. #par



#sc2 xmlmapper_textnodes Mapping Text Nodes #sc2

#par This is different from mapping to child text nodes. It maps a property to the text node that belongs to the
same element. Since this can only apply for a single property it is often combined with attribute mapping like
in the following example: #par

#cdb
public class Song {

    public var year:int;
    public var title:String;
    public var artist:String;
    
}
#cdb

#cdb
<song year="2000" artist="Goldfrapp">Felt Mountain</song>
#cdb

#par Since the text node has no name it has to be mapped explicitly. This is how the mapping for the example above
would be initialized: #par

#cdb
var songBuilder:PropertyMapperBuilder = new PropertyMapperBuilder(Song, new QName("song"));
songBuilder.mapToTextNode("title");
songBuilder.mapAllToAttributes();
#cdb

#par First we explicitly map the text node to the title property, then we map all remaining properties to attributes. #par


#sc2 xmlmapper_childelements Mapping Child Elements #sc2

#par Mapping to child elements allows you to build a hierarchy of nested mappers like shown in the usage example in the 
beginning of this chapter. #par

#cdb
public class Album {

    public var year:int;
    public var title:String;
    public var artist:String;
    public var songs:Array;
    
}

public class Song {

    public var duration:String;
    public var title:String;
    
}
#cdb

#cdb
<album year="2000" artist="Goldfrapp" title="Felt Mountain">
    <song title="Lovely Head" duration="3:50"/>
    <song title="Pilots" duration="4:30"/>
    <song title="Deer Stop" duration="4:07"/>
    <song title="Utopia" duration="4:18"/>
</album>
#cdb

#par In this example the #cdi song #cdi child elements will be mapped into the #cdi songs #cdi property of
the #cdi Album #cdi class. This is how you would set up such a mapper: #par

#cdb
var songBuilder:PropertyMapperBuilder = new PropertyMapperBuilder(Song, new QName("song"));
songBuilder.mapAllToAttributes();

var albumBuilder:PropertyMapperBuilder = new PropertyMapperBuilder(Album, new QName("album"));
albumBuilder.mapToChildElement("songs", songBuilder.build());
albumBuilder.mapAllToAttributes();
#cdb

#par For the #cdi song #cdi element we simply map all properties to attributes. For the #cdi album #cdi element
we map the #cdi songs #cdi Array property to the #cdi song #cdi child element, passing the mapper that we have
built for the child element. We then map all remaining properties to attributes. #par



#sc2 xmlmapper_choices Mapping Choices #sc2

#par This is a variant for the child element mapping mechanism that allows for even greater flexibility.
With choices you can map several different child elements into a single Array property (or single valued property). #par

#cdb
public class Order {

    public var products:Array;
    
}

public class Album {

    public var artist:String;
    public var title:String;
    public var duration:String;
    
}

public class Book {

    public var author:String;
    public var title:String;
    public var pageCount:String;  

}
#cdb

#cdb
<order>
    <album artist="Goldfrapp" title="Felt Mountain"  duration="38:50"/>
    <album artist="Unkle" title="Never, Never, Land"  duration="49:27"/>
    <book author="Karen Duve" title"Rain" pageCount="256"/>
    <book author="Judith Hermann" title"Summerhouse, Later" pageCount="224"/>
</order>
#cdb

#par This time we map the #cdi products #cdi Array property of the #cdi Order #cdi class to multiple different
child elements. This is how you set up the mapper: #par

#cdb
var albumBuilder:PropertyMapperBuilder = new PropertyMapperBuilder(Album, new QName("album"));
albumBuilder.mapAllToAttributes();

var bookBuilder:PropertyMapperBuilder = new PropertyMapperBuilder(Book, new QName("book"));
bookBuilder.mapAllToAttributes();

var orderBuilder:PropertyMapperBuilder = new PropertyMapperBuilder(Order, new QName("order"));
var choice:Choice = new Choice();
choice.addMapper(albumBuilder.build());
choice.addMapper(bookBuilder.build());
orderBuilder.mapToChildElementChoice("products", choice);
#cdb

#par The mappers for the #cdi Book #cdi and #cdi Album #cdi classes are simple: Both simply map all
properties to attributes. For the #cdi Order #cdi class we create a #cdi Choice #cdi instance,
add all child element mappers to it and finally map the #cdi products #cdi property of the #cdi Order #cdi
class to the choice. #par

#par Of course in all the examples we have shown you can also add #cdi [Required] #cdi metadata tags
for improved validation. #par



#sc2 xmlmapper_custom Creating Custom Mappers #sc2

#par Finally there may be a scenario where none of the available mapping types are sufficient. In this case
you can create a custom mapper implementing the #cdi XmlObjectMapper #cdi element from scratch. #par

#par The interface is quite simple: #par

#cdb
public interface XmlObjectMapper {
	
	function get objectType () : ClassInfo;

	function get elementName () : QName;
	
	function mapToObject (element:XML, context:XmlProcessorContext) : Object;

	function mapToXml (object:Object, context:XmlProcessorContext) : XML;
	
}
#cdb

#par It specifies the class and the XML element name that should be mapped and then two methods for mapping
in both directions. In case you have a large and complex XML structure where you can use existing property
mappers for most of the tags, but need a custom mapper for a single tag, you can combine the builtin 
mappers with your custom one: #par

#cdb
var albumBuilder:PropertyMapperBuilder = new PropertyMapperBuilder(Album, new QName("album"));
albumBuilder.mapAllToAttributes();

var bookBuilder:PropertyMapperBuilder = new PropertyMapperBuilder(Book, new QName("book"));
bookBuilder.mapAllToAttributes();

var orderBuilder:PropertyMapperBuilder = new PropertyMapperBuilder(Order, new QName("order"));
var choice:Choice = new Choice();
choice.addMapper(albumBuilder.build());
choice.addMapper(bookBuilder.build());
#hlt choice.addMapper(new MyCustomMapperImpl()); #hlt
orderBuilder.mapToChildElementChoice("products", choice);
#cdb



