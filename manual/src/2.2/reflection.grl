#sc1 reflection_intro Reflection #sc1

#par The reflection module contains convenient classes to reflect on AS3 classes,
methods and properties without the need for cumbersome parsing of XML output from 
#cdi describeType #cdi. #par




#sc2 reflection_basics  The basics #sc2

#par We will use the #cdi flash.geom.Point #cdi class from the core Player API to illustrate
the features of the Spicelib Reflection API. The following listing shows the output of
the #cdi flash.utils.describeType #cdi method if invoked with #cdi Point #cdi as the parameter: #par

#cdb
<type name="flash.geom::Point" base="Class" isDynamic="true" isFinal="true" isStatic="true">
  <extendsClass type="Class"/>
  <extendsClass type="Object"/>
  <method name="interpolate" declaredBy="flash.geom::Point" returnType="flash.geom::Point">
    <parameter index="1" type="flash.geom::Point" optional="false"/>
    <parameter index="2" type="flash.geom::Point" optional="false"/>
    <parameter index="3" type="Number" optional="false"/>
  </method>
  <method name="polar" declaredBy="flash.geom::Point" returnType="flash.geom::Point">
    <parameter index="1" type="Number" optional="false"/>
    <parameter index="2" type="Number" optional="false"/>
  </method>
  <method name="distance" declaredBy="flash.geom::Point" returnType="Number">
    <parameter index="1" type="flash.geom::Point" optional="false"/>
    <parameter index="2" type="flash.geom::Point" optional="false"/>
  </method>
  <accessor name="prototype" access="readonly" type="*" declaredBy="Class"/>
  <factory type="flash.geom::Point">
    <extendsClass type="Object"/>
    <constructor>
      <parameter index="1" type="Number" optional="true"/>
      <parameter index="2" type="Number" optional="true"/>
    </constructor>
    <method name="subtract" declaredBy="flash.geom::Point" returnType="flash.geom::Point">
      <parameter index="1" type="flash.geom::Point" optional="false"/>
    </method>
    <method name="normalize" declaredBy="flash.geom::Point" returnType="void">
      <parameter index="1" type="Number" optional="false"/>
    </method>
    <method name="toString" declaredBy="flash.geom::Point" returnType="String"/>
    <method name="clone" declaredBy="flash.geom::Point" returnType="flash.geom::Point"/>
    <method name="offset" declaredBy="flash.geom::Point" returnType="void">
      <parameter index="1" type="Number" optional="false"/>
      <parameter index="2" type="Number" optional="false"/>
    </method>
    <accessor name="length" access="readonly" type="Number" declaredBy="flash.geom::Point"/>
    <method name="equals" declaredBy="flash.geom::Point" returnType="Boolean">
      <parameter index="1" type="flash.geom::Point" optional="false"/>
    </method>
    <variable name="y" type="Number"/>
    <method name="add" declaredBy="flash.geom::Point" returnType="flash.geom::Point">
      <parameter index="1" type="flash.geom::Point" optional="false"/>
    </method>
    <variable name="x" type="Number"/>
  </factory>
</type>
#cdb

As you see you get information about superclasses, properties (#cdi &lt;accessor&gt; #cdi and 
#cdi &lt;variable&gt; #cdi tags), the constructor and methods and their parameter types. The Spicelib
Reflection API builds on top of the output generated by #cdi describeType #cdi and offers the
following features:

#lst
#lse A convenient API to retrieve that information without the need to parse XML. #lse
#lse A central cache so that invocations of #cdi describeType #cdi and XML parsing occur only once
for each class. #lse
#lse A central repository to register #cdi Converter #cdi instances for any number of target types. #lse
#lse Methods to reflectively set properties and invoke methods of instances while using the registered
converters to automatically convert method parameters and property values if their type does not match
the required type. #lse
#lse The option to register custom classes to represent metadata tags to offer a type-safe way
to reflect on metadata tags and its attributes. #lse
#lst

#par The following sections will explain each of these features. #par




#sc2 reflection_classinfo Obtaining ClassInfo instances #sc2

#par The #cdi ClassInfo #cdi class is the central entry point for all reflection features. 
We chose the name ClassInfo as the name Class is already a top level type in AS3.
There are three ways to obtain an instance of #cdi ClassInfo #cdi: #par

#tbl
#tbr By class name # Example: #cdi ClassInfo.forName("flash.geom.Point"); #cdi #tbr
#tbr By class reference # Example: #cdi ClassInfo.forClass(Point); #cdi #tbr
#tbr By instance # Example: #cdi ClassInfo.forInstance(new Point()); #cdi #tbr
#tbl

#par Of course the last example would only make sense if you use an existing instance of a class
and don't know or don't want to determine the type of the instance first. Otherwise the second
example is the most efficient. If you invoke one of the above three static methods more than
once for the same type, the returned #cdi ClassInfo #cdi instance will be taken from the internal
cache to avoid the overhead of parsing the XML returned by #cdi describeType #cdi again. #par

#par The #cdi ClassInfo #cdi class offers methods to obtain the superclasses and implemented interfaces
(#cdi getSuperclasses #cdi and #cdi getInterfaces #cdi) and the #cdi isType #cdi method that checks if 
the specified parameter is a superclass or one of the implemented interfaces of the class represented
by the #cdi ClassInfo #cdi instance. #par

#par Furhermore the #cdi ClassInfo #cdi class contains methods to reflect on properties and methods
which will be explained in the following sections, 
but before that we will introduce the concept of automatic type conversion, as this concept is used
internally for some of the reflection features related to properties and methods. #par




#sc2 reflection_conversion Automatic type conversion #sc2

#par The #cdi Converters #cdi class of the #cdi org.spicefactory.lib.reflect #cdi package includes a static
#cdi addConverter #cdi method. This allows to register #cdi Converter #cdi instances and map them to
particular types. Internally the Reflection Module will use these Converters to automatically convert
method parameters and property values if their type does not match the required type. This applies
to #cdi Property.setValue #cdi, #cdi Method.invoke #cdi and #cdi Constructor.newInstance #cdi, 
all of them explained in the following sections. They will also be used to convert attributes
of custom metadata tags to the properties of any registered custom metadata class.
The Reflection Module contains some builtin Converters for basic types like #cdi Boolean #cdi,
#cdi String #cdi, #cdi int #cdi, etc., but you can easily add your own. Just implement the
#cdi Converter #cdi interface and add it to the Reflection Module with #cdi Converters.addConverter #cdi. #par




#sc2 reflection_properties Reflecting on properties #sc2

#par The #cdi Property #cdi class allows to obtain information about the type of the property and
if it is readable and writable: #par

#cdb
var ci:ClassInfo = ClassInfo.forClass(Point);
var p:Property = ci.getProperty("x");
trace("type:     " + p.type.name);
trace("readable: " + p.readable);
trace("writable: " + p.writable);
#cdb

#par The output for the code above would be: #par

#cdb
type:     Number
readable: true
writable: true
#cdb

#par Furthermore you can also use the #cdi Property #cdi class to read and write the value
of that property from/to a particular instance of the class that property belongs to: #par

#cdb
var point:Point = new Point(7, 5);
var ci:ClassInfo = ClassInfo.forClass(Point);
var p:Property = ci.getProperty("x");
p.setValue(point, 12);
trace(point.x); // output: 12
#cdb

#par When using #cdi Property.setValue #cdi any necessary type conversion will be done as described
in #ref reflection_conversion #ref. #par

#par Reading and writing property values reflectively is usually not done in application code.
It is most useful for developing frameworks and libraries that have to manage classes not known
until runtime. #par




#sc2 reflection_methods Reflecting on methods #sc2

#par The #cdi Method #cdi class allows to obtain information about the method parameter types and
if they are optional or not: #par

#cdb
var ci:ClassInfo = ClassInfo.forClass(Point);
var m:Method = ci.getMethod("add");
var params:Array = m.parameters;
trace("param count: " + params.length);
var param:Parameter = params[0] as Parameter;
trace("param type: " + param.type.name);
trace("param required: " + param.required);
trace("return type: " + m.returnType.name);
#cdb

#par The output for the code above would be: #par

#cdb
param count: 1
param type: flash.geom::Point
param required: true
return type: flash.geom::Point
#cdb

#par Furthermore you can also use the #cdi Method #cdi class to reflectively invoke
the method on a particular instance of the class that the #cdi Method #cdi instance belongs to: #par

#cdb
var point:Point = new Point(7, 5);
var ci:ClassInfo = ClassInfo.forClass(Point);
var m:Method = ci.getMethod("add");
var result:Point = m.invoke(point, [new Point(3, 3)]);
trace(result.x); // output: 10
#cdb

#par When using #cdi Method.invoke #cdi any necessary type conversion for the method parameters
will be done as described in #ref reflection_conversion #ref. #par

#par Reflectively invoking methods is usually not done in application code.
It is most useful for developing frameworks and libraries that have to manage classes not known
until runtime. #par




#sc2 reflection_methods Reflecting on constructors #sc2

#par The #cdi Constructor #cdi class allows to obtain information about the method parameter types and
if they are optional or not: #par

#cdb
var ci:ClassInfo = ClassInfo.forClass(Point);
var con:Constructor = ci.getConstructor();
var params:Array = con.parameters;
trace("param count: " + params.length);
var param:Parameter = params[0] as Parameter;
trace("param 0 type: " + param.type.name);
trace("param 0 required: " + param.required);
param = params[1] as Parameter;
trace("param 1 type: " + param.type.name);
trace("param 1 required: " + param.required);
#cdb

#par The output for the code above would be: #par

#cdb
param count: 2
param 0 type: Number
param 0 required: false
param 1 type: Number
param 1 required: false
#cdb

#par Furthermore you can also use the #cdi Constructor #cdi class to reflectively 
create new instances: #par

#cdb
var ci:ClassInfo = ClassInfo.forClass(Point);
var con:Constructor = ci.getConstructor();
var instance:Point = con.newInstance([2, 5]);
trace(instance.x); // output: 2
trace(instance.y); // output: 5
#cdb

#par When using #cdi Constructor.newInstance #cdi any necessary type conversion for the method parameters
will be done as described in #ref reflection_conversion #ref. #par

#par Unfortunately there is a bug in Flash Player 9 that causes the type information for the
constructor parameters to get lost under certain circumstances, usually if you create a
#cdi ClassInfo #cdi instance for a class that has not been instantiated yet. If you run into
this bug it is usually sufficient to add a simple #cdi new MyClass() #cdi statement anywhere 
in your code before you start reflecting on that class. The bug is marked as "in progress"
in the #url http://bugs.adobe.com/jira/browse/FP-183 Adobe Jira #url, so hopefully it will
be resolved for Player 10. #par




#sc2 reflection_metadata Reflecting on metadata tags #sc2

#par Introduced with version 1.1.0 the #cdi Metadata #cdi class allows to reflect on metadata tags
added to classes, properties or methods. The #cdi ClassInfo #cdi, #cdi Constructor #cdi, #cdi Method #cdi
and #cdi Property #cdi class now all extend #cdi MetadataAware #cdi directly or indirectly, so that you
can retrieve information on any metadata tags added to one of those elements. (Note that for the 
#cdi Constructor #cdi class the metadata feature was added for "forward compatibility", currently
the Flash Player ignores metadata tags placed on constructors). #par

#par There are two ways to reflect on metadata. The one described in this section just provides
untyped String-based access to tags and its attributes. The following section then explains how you
can register custom classes mapping to metadata tags to allow for type-safe reflection on metadata. #par

#par Consider this simple class: #par

#cdb
public class MyClass {

    [CustomMetadata(customAttribute="foo")]
    public function someMethod () : void {
        trace("someMethod invoked");    
    } 
    
}
#cdb   

#par When you compile classes with custom metadata make sure that you add it to the
#cdi -keep-as3-metadata #cdi compiler option, as it will be ignored otherwise: #par

#cdb
mxmlc -keep-as3-metadata+=CustomMetadata,OtherTag1,OtherTag2 ... [other options]
#cdb

#par If you use this option when compiling an SWC all projects that use that SWC
do not need to explicitly specify the metadata tags to keep as they will be included
automatically. #par

#par Now you can obtain information about such a tag at runtime: #par

#cdb
var ci:ClassInfo = ClassInfo.forClass(MyClass);
var m:Method = ci.getMethod("someMethod");
var tags:Array = m.getMetadata("CustomMetadata");
trace("number of metadata tags: " + tags.length);
var meta:Metadata = tags[0] as Metadata;
trace("customAttribute = " + meta.getArgument("customAttribute"));
#cdb 

#par The output for the above code would be: #par

#cdb
number of metadata tags: 1
customAttribute = foo
#cdb

#par Note that #cdi getMetadata #cdi always returns an Array because multiple tags of the same
type can be place on the same element. If no such tag exists for a particular element an empty
Array will be returned. #par



#sc2 reflection_metadata_mapping Mapping classes to metadata tags #sc2

#par While the API demonstrated in the previous section may be sufficient for simple use cases,
it would be more convenient to work with metadata in a type-safe way if you are doing more
than just simple lookups (like complex configuration tasks performed for custom metadata for example). #par

#par If you want to work with custom classes mapped to metadata tags you have to perform the following
tasks: #par

#lst
#lse Create a class with properties that correspond to the attributes of the metadata tag. #lse
#lse Add a #cdi [Metadata] #cdi tag to this custom class, optionally specifying the types on which this tag
is allowed to occur. #lse
#lse Optionally add a #cdi [DefaultProperty] #cdi tag to one of the properties of that class. #lse
#lse Register the class with #cdi Metadata.registerMetadataClass #cdi. #lse
#lse Add the metadata tag to the #cdi -keep-as3-metadata #cdi compiler option. #lse
#lst

#par We will walk you through all these steps with a concrete example. Consider the following
class: #par

#cdb
public class LoginController {

    [EventHandler(name="login", type="com.foo.LoginEvent")]
    public function handleLogin () : void {
        trace("handleLogin invoked");    
    } 
    
}
#cdb

#par Let's assume you are building a framework that will interpret the #cdi EventHandler #cdi tag
and invoke the annotated method whenever such an Event occurs (in fact Parsley 2 will include
metadata-driven configuration options like this). The first step would be to create a class
that represents this tag: #par

#cdb
[Metadata(name="EventHandler", types="method")]
public class EventHandlerMetadata {

    [DefaultProperty]
    public var name:String;
    
    public var type:ClassInfo;

}
#cdb

#par As you see, the two properties correspond to the two attributes in the metadata tags. You are
not limited to working with Strings here, the Spicelib will automatically convert the attributes
to the property type, as long as there is a builtin Converter for that type. If you are working
with properties that the Spicelib cannot convert out-of-the-box, you can register your own
#cdi Converter #cdi instance as described in #ref reflection_conversion #ref, but you should
rarely have the need to do so. In addition to the usual type conversion the metadata support
handles an additional use case that is quite common: You can define a comma-separated value
for an attribute when the property type is Array, in this case the Spicelib will split the
value accordingly (but without type conversions for the individual elements). #par

#par Above the class declaration you have to add the #cdi [Metadata] #cdi tag to declare
that this is a class that should be mapped to a custom metadata tag. The attribute specifies
the name of the tag (as we used it in the #cdi LoginController #cdi example class). If this
attribute is omitted it will use the non-qualified name of the class as the tag name.
The second attribute specifies on which types the metadata tag should be mapped to this class.
Permitted values are #cdi class #cdi, #cdi constructor #cdi, #cdi method #cdi and #cdi property #cdi
(but tags on the constructor are currently ignored by the Flex compilers, so this is included only
for eventual future use). If this attribute is omitted Spicelib will map the metadata tag for all
of these types. With this option you can for example map different classes for the same tag name,
in case you have a different set of attributes for annotated methods than for properties. #par 

#par Finally one of the two properties was defined as #cdi [DefaultProperty] #cdi. This means
that this property will be set whenever an attribute is specified without a key like 
in the following example: #par

#cdb
[EventHandler("login")]
#cdb

#par Now that you have created the class that you want to map to metadata, you have to register
it like this: #par

#cdb
Metadata.registerMetadataClass(EventHandlerMetadata);
#cdb

#par Make sure that you register the class before you reflect on a class that uses this tag
for the first time. Finally don't forget to add it to the #cdi -keep-as3-metadata #cdi compiler option.
Now you can start reflecting on those tags: #par

#cdb
var ci:ClassInfo = ClassInfo.forClass(LoginController);
var m:Method = ci.getMethod("handleLogin");
var tags:Array = m.getMetadata(EventHandlerMetadata);
trace("number of metadata tags: " + tags.length);
var meta:EventHandlerMetadata = tags[0] as EventHandlerMetadata;
trace("name = " + meta.name);
trace("type = " + meta.type.name);
#cdb

#par The output for the above code would be: #par

#cdb
number of metadata tags: 1
name = login
type = com.foo.LoginEvent
#cdb

#par Note that you no longer use Strings as keys in your #cdi getMetadata #cdi invocations,
you now use the class that represents the tag as the key (which is much better in terms of
type-safety). #par

#par If an error occurs while processing metadata tags (for example a type conversion that fails)
it will be silently swallowed. This is because an illegal metadata tag should not prevent you
from reflecting on the annotated method. We are considering adding a kind of optional "strict" mode
to a future release that would throw an Error in such a case or any other means to explicitly
validate tags. #par




#sc2 reflection_appdomains Working with ApplicationDomains #sc2

#par Finally, also introduced with version 1.1.0, Spicelib now supports ApplicationDomains.
In case you work with Flex Modules or other SWF files that are loaded in a separate
ApplicationDomain you can now tell the Spicelib Reflection API explicitly to use this
domain. For this purpose the three methods you can use to obtain a #cdi ClassInfo #cdi
instance have been modified to support an optional #cdi ApplicationDomain #cdi parameter: #par

#cdb
static function forName (name:String, domain:ApplicationDomain = null) : ClassInfo
		
static function forClass (clazz:Class, domain:ApplicationDomain = null) : ClassInfo

static function forInstance (instance:Object, domain:ApplicationDomain = null) : ClassInfo
#cdb

#par Note that if you use a different domain you would have to specifiy it for all of these
methods, not only the one that takes a String argument. This is because even if you pass
an existing #cdi Class #cdi instance, the Spicelib might still need to know the domain to reflect
on dependent types, since it uses #cdi describeType #cdi internally which provides type
information for superclasses, implemented interfaces, property types and method parameter types
in the form of Strings. To convert these Strings to actual #cdi Class #cdi instances the 
specified domain will be used internally. Unfortunately AS3 does not have a similar construct
like Javas #cdi getClassLoader #cdi method which would make the #cdi ApplicationDomain #cdi
parameter obsolete for the second and third method. #par

#par If you omit the optional second parameter, the #cdi ClassInfo #cdi class will work
like in previous versions, simply using #cdi ApplicationDomain.currentDomain #cdi. #par



