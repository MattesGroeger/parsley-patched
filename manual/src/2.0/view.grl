#sc1 view_intro Flex Component Wiring #sc1

#par So far all objects that "live" inside a Parsley Context have been defined with either MXML, XML or ActionScript as
detailed in #ref config_intro #ref. For Flash Applications these mechanisms will usually be sufficient as it is very likely
that you are able to conveniently define all managed objects in XML or ActionScript - including view elements.
For Flex Application this approach is not ideal since you'll prefer to declare your components in your MXML files
within the component hierarchy and not in a separate Parsley Context MXML configuration class.
So we'll need a different mechanism to connect these components defined within your MXML view definitions
to objects declared with Parsley configuration files. The solution Parsley offers for this use case will be
described in this chapter. #par



#sc2 view_config Component Configuration #sc2

#par To configure a Flex Component to take advantage of Parsley's IOC Container features the following steps are required: #par

#lst
#lse Configure the Component with Parsley Metadata Tags the same way you would configure any other object. #lse
#lse Tell Parsley that this Component wants to be part of the IOC Container by firing a special configuration event. #lse
#lst

#par Let's illustrate this with a simple example: #par

#cdb
<mx:Panel 
    xmlns:mx="http://www.adobe.com/2006/mxml"
    #hlt addedToStage="dispatchEvent(new Event('configureIOC', true));" #hlt
    >
    
    <mx:Script>
        <![CDATA[
            import com.bookstore.events.*;
            import com.bookstore.model.*;
            
            [Bindable]
            private var user:User;
            
            #hlt [Inject] #hlt
            public var mediator:LoginMediator;    
            
            #hlt [MessageHandler] #hlt
            public function handleLogin (event:LoginEvent) : void {
                this.user = event.user;            
            }
        ]]>
    </mx:Script>
    
    <mx:text text="Current User: {user.name}"/>
    
    <!-- some more components ... -->
    
</mx:Panel> 
#cdb

#par The metadata tags used in the example work the same way as for objects defined in Parsley configuration files.
So your Flex Component can participate in the Parsley Messaging infrastructur and request injections of objects from
the Context. To trigger the configuration of the Component we fire an event when it gets added to the stage.
The event type has to be #cdi 'configureIOC' #cdi which Parsley registers a listener for on the Flex SystemManager. 
Furthermore it must be a bubbling event, thus the second parameter is #cdi true #cdi. #par

#par Note that in this example we did not follow the best practice to use a constant for the event type as it is our goal to keep the Flex
Component free from imports of the Parsley API. So it will continue to work in other environments without Parsley.
The event would simply be ignored then and the property values could be set directly in MXML instead of being injected
by an IOC Container. You could of course define such a constant within your application classes. #par

#par If you don't mind to couple your Component to the Parsley API the framework offers a special #cdi <Configure/> #cdi
tag as an alternative: #par

#cdb
<mx:Panel 
    xmlns:mx="http://www.adobe.com/2006/mxml"
    xmlns:parsley="http://www.spicefactory.org/parsley/flex"
    >
    
    #hlt <parsley:Configure/> #hlt
    
    <!-- ... -->
    
</mx:Panel> 
#cdb



#sc2 view_lifecycle Component Lifecycle #sc2

#par Due to the fact that Flex Components are connected to the IOC Container "on the fly" the lifecycle for Components
is different than for objects defined directly in the container. This affects the #cdi [PostConstruct] #cdi and
#cdi [PreDestroy] #cdi metadata tags. #par

#sub Methods annotated with #cdi [PostConstruct] #cdi #sub

#par For an object declared directly within a Parsley configuration file these methods get executed after the 
container has instantiated and configured the object. For a Flex Component that is dynamically wired it
will be invoked after the container caught the configuration event dispatched by the Component and after
all injections have been processed. #par

#sub Methods annotated with #cdi [PreDestroy] #cdi #sub

#par For an object declared directly within a Parsley configuration file these methods only get executed after the 
container has been destroyed with a call to #cdi Context.destroy() #cdi. For a Flex Component that is dynamically wired it
will additionally be invoked after the Component has been removed from the stage. Of course that means that the same
instance can have multiple invocations of its PostConstruct and PreDestroy methods in case it gets removed and re-added
to the stage. #par

#par You should also be aware of some strange side effects when using the Flex PopUpManager for example.
In my tests I noticed that it has a strange way of initializing popups, often leading to a sequence
of #cdi addedToStage #cdi and #cdi removedFromStage #cdi events. In this case injections might be processed twice. #par



#sc2 view_init Initializing the View Wiring Support #sc2

#par In case you are using any of the static methods of the #cdi FlexContextBuilder #cdi class, there is nothing you
need to do as the Flex View Wiring Support will implicitly be initialized by any of these methods: #par

#cdb
FlexContextBuilder.build(BookStoreConfig); // triggers view management
#cdb

#par In rare cases where you would build a Parsley Flex Application but not use MXML configuration at all (for example
confining yourself to use XML configuration files) you'd need to explicitly add a Context to the Parsley ViewManager: #par

#cdb
var context:Context = XmlContextBuilder.build("config.xml");
RootViewManager.addContext(context);
#cdb



