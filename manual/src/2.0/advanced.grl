#sc1 advanced_intro Advanced IOC Container Features #sc1

#par This chapter lists several features that go beyond the configuration features listed in previous chapters. #par


#sc2 advanced_factories Using Factories #sc2

#par Sometimes configuring the target object directly may not be sufficient. Maybe you want to execute some complex
logic on object creation that would be difficult to setup declaratively. In these cases you can use a factory instead.
The factory is a normal AS3 class that you can configure like any other class in Parsley, using Metadata, MXML or XML tags.
The only difference is that one method is marked as a factory method (again using Metadata, MXML or XML): #par

#cdb
class CategoryFactory {

    public var categoryName:String;
    
    [Inject]
    public var bookManager:BookManager;
    
    [Factory]
    public function createCategory () : Category {
        var books:Array = bookManager.getBooksForCategory(categoryName);
        return new Category(categoryName, books);
    }
}
#cdb

#par You can then use this factory in your configuration, for example in MXML: #par

#cdb
<mx:Object 
    xmlns:mx="http://www.adobe.com/2006/mxml"
    xmlns:model="com.bookstore.model.*">
    
    <model:BookManager/>
    
    <model:CategoryFactory id="historyCategory" categoryName="history"/>

    <model:CategoryFactory id="politicsCategory" categoryName="politics"/>

    <model:CategoryFactory id="artsCategory" categoryName="arts"/>
        
</mx:Object> 
#cdb

#par Each of the factories we defined above will get the #cdi BookManager #cdi instance injected and then produce
instances of #cdi Category #cdi. #par

#par The special thing about using factories is that under the hood Parsley actually
creates #str two #str object definitions for each factory: One for the factory itself and one for the type the
factory method produces. This means that you can also place metadata tags on the target type (in this case the
#cdi Category #cdi class) if you want the object that the factory produces to send and receive application messages
managed by Parsley for example. #par
 
#par This also means that you can use the factory #str and #str the objects it creates at injection points, although
in most cases you'll be interested in the objects produced by the factory: #par

#cdb
[Inject(id="historyCategory")]
public var historyBooks:Category;
#cdb

#par It is recommended not to use factory methods with a return type of #cdi Object #cdi like this: #par

#cdb
[Factory]
public function createInstance () : Object {
#cdb

#par It would work, Parsley would happily process this kind of factory method. But you'll lose some of
Parsley's useful capabilities, since it uses the return type of the method for producing the object
definition for the target type. If the target type is just Object, the metadata tags on the objects
this factory actually produces would not be processed, since this happens #str before #str the factory method
will be invoked for the first time. Furthermore you cannot use objects produced by such a factory
for Dependency Injection by Type, since the type can only be determined dynamically. You would then
be constrained to Injection by Id. #par

#par Of course, like with most other Parsley features, you may also declare the factory method in 
MXML or XML. This may come in handy in some edge cases, for example for a factory that has more than
one method that produces objects. In this case placing metadata tags in the class itself would not
be possible (only one #cdi [Factory] #cdi tag is allowed). #par


#sub MXML Example #sub

#cdb
<Object id="monkey" type="{ZooFactory}">
    <Factory method="createMonkey"/> 
</Object>
<Object id="polarBear" type="{ZooFactory}">
    <Factory method="createPolarBear"/> 
</Object>
#cdb
 
#sub XML Example #sub

#cdb
<object id="monkey" type="com.example.ZooFactory">
    <factory method="createMonkey"/> 
</object>
<object id="polarBear" type="com.example.ZooFactory">
    <factory method="createPolarBear"/> 
</object>
#cdb



#sc2 advanced_async Asynchronous Object Initialization #sc2

#par A lot of operations in the Flash Player execute asynchronously. So it might happen that you want an object
configured in the Parsley IOC Container to load some data or assets first, before the rest of the Context gets
initialized and before this asynchronously initializing object gets injected into other objects. In this cases
you can use the #cdi [AsyncInit] #cdi tag on any #cdi EventDispatcher #cdi that fires events when the initialization
is completed (or if it has failed): #par

#cdb
#hlt [AsyncInit] #hlt
public class FileLoader extends EventDispatcher {

    public var filename:String;

    #hlt [PostConstruct] #hlt
    public function init () : void {
        var loader:URLLoader = new URLLoader();
        loader.addEventListener(Event.COMPLETE, fileLoaded);
        loader.addEventListener(IOErrorEvent.IO_ERROR, handleError);
        loader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, handleError);
        loader.load(new URLRequest(filename));            
   }
   
   private function fileLoaded (event:Event) : void {
       // handle loaded file
       #hlt dispatchEvent(new Event(Event.COMPLETE)); #hlt
   }
   
   private function handleError (event:ErrorEvent) : void {
       #hlt dispatchEvent(new ErrorEvent(ErrorEvent.ERROR, false, false, event.text)); #hlt
   }
   
}
#cdb

#par In the example above the #cdi [AsyncInit] #cdi tag tells the framework that this is an asynchronously initializing
object. In the method annotated with #cdi [PostConstruct] #cdi which will be invoked after configuration and
dependency injection has been processed for that object (see #ref advanced_lifecycle #ref for details) we start the
loading process. Depending on whether the loading succeeds or not we then dispatch either an #cdi Event.COMPLETE #cdi
or an #cdi ErrorEvent.ERROR #cdi. The container will listen for those two events. In case of #cdi Event.COMPLETE #cdi it
will proceed with Context initialization. In case of #cdi ErrorEvent.ERROR #cdi the whole Context initialization process
will be cancelled. #par

#sub Switching event types #sub

#par #cdi Event.COMPLETE #cdi and #cdi ErrorEvent.ERROR #cdi are the default event types to signal whether initialization
has completed or failed. They can be switched with attributes of the #cdi [AsyncInit] #cdi tag: #par

#cdb
[AsyncInit(completeEvent="myCustomCompleteEvent",errorEvent="myCustomErrorEvent")]
#cdb

#sub Initialization order #sub

#par If you use more than one asynchronously initializing object and one depends on the other you may want to 
explicitly specify the initialization order. You can do that with the order attribute: #par

#cdb
[AsyncInit(order="1")]
#cdb

#par The default value if you omit this attribute is #cdi int.MAX_VALUE #cdi so that all objects without an order attribute
will execute last and in arbitrary order. The attribute can be set to any positive or negative integer value. #par

#par Of course you can also omit all the metadata tags and declare everything in MXML or XML: #par

#sub MXML Example #sub

#cdb
<Object id="welcomeText" type="{FileLoader}">
    <AsyncInit order="1"/>
    <PostConstruct method="init"/>
    <Property name="filename" value="welcome.txt"/>
</Object>
#cdb
 
#sub XML Example #sub

#cdb
<object id="welcomeText" type="com.example.FileLoader">
    <async-init order="1"/>
    <post-construct method="init"/>
    <property name="filename" value="welcome.txt"/>
</object>
#cdb


#sc2 advanced_object_lifecycle Object Lifecycle #sc2

#par If you want the Parsley Container to invoke methods on your object when it is created or when it is destroyed,
you can add the #cdi [PostConstruct] #cdi or #cdi [PreDestroy] #cdi metadata tags to the corresponding methods: #par

#cdb
[PostConstruct]
public function init () : void {
    [...]
}
[PreDestroy]
public function dispose () : void {
    [...]
}
#cdb

#par The methods marked with #cdi [PostConstruct] #cdi get invoked after the object has been instantiated and
all injections have been processed. #par

#par The methods marked with #cdi [PreDestroy] #cdi get invoked after the Context instance they belong to has been
destroyed with #cdi Context.destroy() #cdi. See #ref advanced_lifecycle #ref for details. #par

#par For Flex Components declared in regular MXML files and wired to the Context as described in #ref view_intro #ref
the lifecycle is different: For those objects the methods get invoked whenever the object is added to or removed from the
stage respectively. Of course the #cdi [PreDestroy] #cdi method additionally gets invoked if the Context the object
was wired to was destroyed. #par



#sc2 advanced_modular Modular Contexts #sc2

#par In larger applications you may want to split your application into modules which are
loaded on demand. In this case it would be unfortunate to have a monolithic Context
that is fully loaded and initialized at application startup. Even splitting the configuration into
multiple files like shown in #ref config_combine #ref won't help since those files will be merged into
a single Context and loaded and initialized as if it was a single large configuration file. #par

#par This is where another feature of Parsley comes in handy: when creating a #cdi Context #cdi
you can define an existing context as its parent with optional parameters of all the various context builder methods
shown in #ref config_intro #ref: #par

#cdb
var parent:Context = ...;
FlexContextBuilder.build(BookStoreConfig, parent);
#cdb

#par or: #par

#cdb
var parent:Context = ...;
XmlContextBuilder.build("config.xml", parent);
#cdb


#par The parent context may be the main context loaded at
application startup and the child context may be one required by a module loaded on demand.
In the configuration for the child Context you can use any object from the parent Context for Dependency Injection 
(but not vice versa). #par

#par When an application module is unloaded you can destroy the child #cdi Context #cdi
(for details see #ref advanced_lifecycle #ref) without affecting the parent. You can create deeply
nested hierarchies of contexts, but often the structure would be rather flat, with one 
root context and any number of child contexts on the same level. #par

#par If you are using Flex Modules for modularization it will be even easier. Parsley 2 comes 
with special integration features as described in #ref modules_intro #ref. #par



#sc2 advanced_lifecycle Context Lifecycle #sc2

#par If you load multiple #cdi Context #cdi instances as modules like described
in the previous section, you may want to get rid of them when you unload a module. Actually
that is quite easy, just do this: #par

#cdb
context.destroy();
#cdb

#par When using the Parsley support for Flex Modules as described in #ref modules_intro #ref it is
even easier. You don't have to explicitly destroy the Context then, it will happen automatically
when the Flex Module gets unloaded. #par

#par When a Context gets destroyed the following actions occur: #par

#lst
#lse All objects configured in the destroyed Context stop receiving messages dispatched by Parsleys central
#cdi MessageRouter #cdi. This affects all elements annotated with #cdi MessageHandler #cdi, #cdi MessageBinding #cdi
or #cdi MessageInterceptor #cdi. #lse

#lse If any objects declared in the destroyed Context declared #cdi ManagedEvents #cdi they will be ignored from now
on and no longer dispatched trough Parsleys #cdi MessageRouter #cdi. #lse

#lse All methods annotated with #cdi [PreDestroy] #cdi (or the corresponding MXML or XML tags) 
on any object of the destroyed Context get invoked. #lse

#lse The destroyed Context will remove all internal references to the configured objects so they are eligible
for garbage collection. (Of course you have to make sure that your application does not retain any references
to those objects). #lse

#lse The Context may no longer be used after invoking #cdi destroy #cdi. Any subsequent method invocations
on that Context throw Errors. The parent of the destroyed Context (if any) is not affected and may continue
to operate normally. #lse
#lst




