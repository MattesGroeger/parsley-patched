#sc1 messaging_intro Messaging #sc1

#par Parsley 2 introduces a new generic Messaging Framework that allows you to exchange messages between objects
in a fully decoupled manner. Decoupled not only means that the sender and the receiver do not have to know each other.
It is equally important that the sending and receiving objects are also fully decoupled from the framework itself.
This is an advantage ignored by most other Flex Frameworks (including version 1 of Parsley) where you have to use
objects or static methods from the Framework API for dispatching application events or messages. Why is that important?
If your objects are decoupled from the framework you can reuse them in a different context where you might want to use
a different framework or no framework at all. For example you might want to wire dispatching and receiving instances
programmatically for Unit Tests without the extra burden to initialize an application framework. #par

#par The Parsley Messaging Framework is generic in a sense that it does not impose a particular usage style.
This is also a difference to some of the existing Flex MVC Frameworks which often advocate a certain structure
and usage pattern or even offer concrete base classes for the controller, model and view parts. With Parsley 2
you are completely free to design your application architecture. In case you do use the Messaging Framework to 
build a classic MVC architecture you may want to read #ref mvc_intro #ref in addition to this chapter. #par



#par This chapter describes how you can configure objects for sending and receiving messages. 
For every configuration option examples for AS3 Metadata, MXML and XML configuration are included. #par



#sc2 messaging_dispatching Dispatching Messages #sc2

#par For an object that wants to dispatch messages managed by Parsley you have the following setup options: #par

#lst
#lse #ref messaging_managed_events #ref if the dispatching object is a regular #cdi EventDispatcher #cdi. #lse
#lse #ref messaging_injected_dispatchers #ref if your messages are not subclasses of #cdi Event #cdi. #lse
#lse #ref messaging_api #ref in rare cases where you need to use the Framework API directly #lse
#lst


#sc2 messaging_receiving Receiving Messages #sc2

#par For an object that wants to receive and process messages managed by Parsley you have the following setup options: #par

#lst
#lse #ref messaging_handlers #ref for methods that should be invoked when a particular message is dispatched. #lse
#lse #ref messaging_bindings #ref for properties that should be set when a particular message is dispatched. #lse
#lse #ref messaging_interceptors #ref for intercepting, and optionally cancelling or deferring then redispatching a message 
before it is processed by handlers or bindings. #lse
#lse #ref messaging_api #ref in rare cases where you need to use the Framework API to register any of the
features listed above. #lse
#lst



#sc2 messaging_managed_events Managed Events #sc2

#par If the class that you want to dispatch messages managed by Parsley is a regular #cdi EventDispatcher #cdi this
is the most convenient option. It would work for any existing #cdi EventDispatcher #cdi implementation even if it wasn't
designed with Parsley in mind. It requires two steps: #par

#lst
#lse Declare the events that your class dispatches with regular [Event] tags. This is good practice anyway, whether you are
using Parlsey or not, as it improves the readability of your classes and the ASDoc output where all events declared with
this tag are included. #lse
#lse Tell Parsley which of those declared events should be "managed" so that they are available for message receivers
configured for the framework. Like for all messaging features you can use AS3 Metadata, MXML or XML tags for this step. #lse
#lst

#sub Metadata Example #sub

#cdb
[Event(name="loginSuccess",type="com.bookstore.events.LoginEvent")]
[Event(name="loginFailed",type="com.bookstore.events.LoginEvent")]
[Event(name="stateChange",type="flash.events.Event")]
[ManagedEvents("loginSuccess,loginFailure")]
public class LoginServiceImpl extends EventDispatcher implements LoginService {

    [...]
    
    private function handleLoginResult (user:User) : void {
        dispatchEvent(new LoginEvent("loginSuccess", user));
    }
    
}
#cdb

#par In the example above the service declares three events. Two of them (#cdi loginSuccess #cdi and #cdi loginFailure #cdi) 
are application events and should be managed by Parsley and dispatched to all objects in the Context interested in that event. 
The third one is a low-level event only of interest for objects interacting directly with that service. Those objects may
still register a regular event listener for that event. #par

#par The example method above shows how a result handler (that probably was registered as a handler for a remote service
invocation) translates the result into an event and simply dispatches it. No #cdi FrontController.getInstance().dispatch... #cdi
or anything like that. Since #cdi loginSuccess #cdi was declared as a managed event it will be passed to all #cdi MessageHandlers #cdi
configured in Parlsey. #par

#sub MXML Example #sub

#cdb
<Object type="{LoginServiceImpl}">
    <ManagedEvents names="['loginSuccess','loginFailure']"/>
</Object>
#cdb

#par If you declare the managed events in MXML you can omit the #cdi [ManagedEvents] #cdi metadata tag from the previous example.
Note that you still have to include the #cdi [Event] #cdi metadata tags, since those are not a configuration artifact of Parsley
but a regular Flash API feature. #par
 
#sub XML Example #sub

#cdb
<object type="com.bookstore.services.LoginServiceImpl">
    <managed-events names="loginSuccess,loginFailure"/>
</object>
#cdb

#par As always very simliar to MXML configuration apart from several notation differences. #par



#sc2 messaging_injected_dispatchers Injected MessageDispatchers #sc2

#par Sometimes you don't want to work with events for your application messages. Somehow several event semantics may not
make much sense in a particular scenario. Application events managed by Parsley cannot "bubble", #cdi stopPropagation #cdi
would not have any effect in the Parsley message processing sequence and for fully decoupled messaging you may even want
to avoid that the message receiver can get hold of the message dispatcher through #cdi event.target #cdi. #par

#par In those cases Parsley offers the option to use any class as an application message, whether it extends #cdi flash.events.Event #cdi
or not. You can then request the framework to inject a message dispatcher function that you can use for your custom application messages.
Assuming you created the following simple message class: #par

#cdb
class LoginMessage {

    public var user:User;
    
    public var role:String;
    
    function LoginMessage (user:User, role:String) {
        this.user = user;
        this.role = role;
    }
    
}
#cdb

#par You can then use it in a service like this: #par

#cdb
public class LoginServiceImpl implements LoginService {

    [MessageDispatcher]
    public var dispatcher:Function;

    [...]
    
    private function handleLoginResult (user:User) : void {
        dispatcher(new LoginMessage(user));
    }
    
}
#cdb

#par Now your service does not extend #cdi EventDispatcher #cdi. Instead it declares a variable of type #cdi Function #cdi
annotated with the #cdi [MessageDispatcher] #cdi tag which instructs Parsley to inject a message dispatcher function 
on object creation. You can then simply pass any kind of object to this dispatcher function. #par

#sub MXML Example #sub

#cdb
<Object type="{LoginServiceImpl}">
    <MessageDispatcher property="dispatcher"/>
</Object>
#cdb
 
#sub XML Example #sub

#cdb
<object type="com.bookstore.services.LoginServiceImpl">
    <message-dispatcher property="dispatcher"/>
</object>
#cdb

#par If you don't want to use Metadata tags you can also request the dispatcher injection with MXML or XML configuration. #par



#sc2 messaging_handlers MessageHandlers #sc2

#par Message Handlers are the most common approach for the receiving side. You can declare methods to be invoked when
a particular application message gets dispatched. In the most simple case the method will simply be selected by
parameter type: #par

#sub Metadata Example #sub

#cdb
[MessageHandler]
public function handleLogin (message:LoginMessage) : void {
#cdb

#par In this case the method will be invoked whenever a message of a matching type (or subtype) gets dispatched. #par

#sub MXML Example #sub

#cdb
<Object type="{LoginAction}">
    <MessageHandler method="handleLogin"/> 
</Object>
#cdb
 
#sub XML Example #sub

#cdb
<object type="com.bookstore.actions.LoginAction">
    <message-handler method="handleLogin"/> 
</object>
#cdb

#par There is also a variant where you split properties of the message class to arguments of the message handler method: #par

#cdb
[MessageHandler(type="com.bookstore.events.LoginMessage",messageProperties="user,role"]
public function handleLogin (user:User, role:String) : void {
#cdb

#par Note that in this case you also have to declare the message type since it cannot be detected from the
parameter type. #par

#par Finally you may encounter a situation where selection by message type is not sufficient. If you dispatch
the same message type in different scenarios and application states you may want to further refine the message
selection process. See #ref messaging_selectors #ref for details. #par



#sc2 messaging_bindings MessageBindings #sc2

#par Message Bindings are simply a shortcut, where you want to bind a property of a class to a property of a message,
that should be updated whenever a message of a matching type is dispatched. 
In the following example the user property of the example will be set to the value of the user property of
the #cdi LoginMessage #cdi instance whenever such a message is dispatched. #par

#sub Metadata Example #sub

#cdb
[MessageBinding(messageProperty="user",type="com.bookstore.events.LoginMessage")]
public var user:User;
#cdb

#sub MXML Example #sub

#cdb
<Object type="{LoginServiceImpl}">
    <MessageBinding 
        targetProperty="user" 
        messageProperty="user"
        type="{LoginMessage}"
    />
</Object>
#cdb
 
#sub XML Example #sub

#cdb
<object type="com.bookstore.services.LoginServiceImpl">
    <message-binding 
        target-property="user" 
        message-property="user"
        type="com.bookstore.events.LoginMessage"
    />
</object>
#cdb

#par As with #cdi MessageHandlers #cdi you may want to use Selectors with #cdi MessageBindings #cdi. 
See #ref messaging_selectors #ref for details. #par



#sc2 messaging_interceptors MessageInterceptors #sc2

#par This is the third and final option for the receiving side. Interceptors may come in handy when you want to
decide whether or not the message should be passed to handlers and bindings based on application state or user decisions. 
Interceptors have the following characteristics: #par  

#lst
#lse All registered interceptors execute before any handlers or bindings are executed. #lse
#lse Interceptors can optionally suspend the message processing and resume it at a later time. #lse
#lst

#par A simple example where you might want to use such an interceptor, is when you have
an application that can be used without being logged in, but does include some actions
which will not be accessible without login. In that case an interceptor could suspend
the message processing, present a login dialog and resume the message processing after
successful login. #par

#par Another example would be to show a simple warning before any delete operation
is actually performed like in the following example: #par

#cdb
public class DeleteItemInterceptor implements ActionInterceptor {
 
    [MessageInterceptor(type="com.bookstore.events.ShoppingCartDeleteEvent")]
    public function interceptDeleteEvent (processor:MessageProcessor) : void {
        var listener:Function = function (event:CloseEvent) : void {
            if (event.detail = Alert.OK) {
                processor.proceed();
            }  
        };      
        Alert.show("Do you really want to delete this item?", "Warning", 
            Alert.OK | Alert.CANCEL, null, listener);
    }
 
}
#cdb 

#par When the user hits cancel, the #cdi MessageProcessor #cdi never resumes and no subsequent handler or bindings will
be executed. #par

#par Like with MessageBindings you have to declare the message type since it cannot be detected from the method signature.
Interceptor methods must always have a single parameter of type #cdi MessageProcessor #cdi. 
Again you can use MXML or XML instead of Metadata tags for declaring the interceptor methods: #par

#sub MXML Example #sub

#cdb
<Object type="{LoginServiceImpl}">
    <MessageInterceptor 
        method="interceptDeleteEvent" 
        type="{ShoppingCartDeleteEvent}"
    />
</Object>
#cdb
 
#sub XML Example #sub

#cdb
<object type="com.bookstore.services.LoginServiceImpl">
    <message-interceptor
        method="interceptDeleteEvent"
        type="com.bookstore.events.ShoppingCartDeleteEvent"
    />
</object>
#cdb

#par It is recommended to use interceptors sparingly as it is the only feature of the Messaging Framework that ties
you to the Parsley API, as we have to pass a #cdi MessageProcessor #cdi instance to you so that you are able to
#cdi rewind #cdi or #cdi proceed #cdi with message processing. #par



#sc2 messaging_selectors Using Selectors #sc2

#par In the examples for the sections about MessageHandlers, MessageBindings and MessageInterceptors the matching methods or 
properties were always determined solely by the type (class) of the message. Sometimes that may not be sufficient if you dispatch the
same message type in different scenarios or application states. In such a case you can refine the selection process with
custom selectors. #par

#par If you are using events the type property of the Event class can serve as a selector: #par

#cdb
[MessageHandler(selector="loginSuccess")]
public function handleLogin (message:LoginEvent) : void {
    [...]
}

[MessageHandler(selector="loginFailure")]
public function handleError (message:LoginEvent) : void {
    [...]
}
#cdb

#par In the example above the #cdi handleLogin #cdi method will only be invoked when the #cdi type #cdi property of the
#cdi LoginEvent #cdi instance has the value #cdi loginSuccess #cdi. #par

#par For custom message types that do not extend #cdi flash.events.Event #cdi there is no default selector property,
but it can be easily declared with the #cdi [Selector] #cdi metadata tag on a property of the message class: #par

#cdb
class LoginMessage {

    public var user:User;
    
    [Selector]
    public var role:String;
    
    [...]
}
#cdb

#par Now you can select message handlers based on the role of the user that logged in: #par

#sub Metadata Example #sub

#cdb
[MessageHandler(selector="admin")]
public function handleAdminLogin (message:LoginMessage) : void {
#cdb

#sub MXML Example #sub

#cdb
<Object type="{AdminLoginAction}">
    <MessageHandler method="handleAdminLogin" selector="admin"/> 
</Object>
#cdb
 
#sub XML Example #sub

#cdb
<object type="com.bookstore.actions.AdminLoginAction">
    <message-handler method="handleAdminLogin" selector="admin"/> 
</object>
#cdb



#sc2 messaging_api Using the MessageRouter programmatically #sc2

#par In normal application code you should try to avoid to directly interact with the Parsley API to keep your classes
decoupled from the framework. But if in some edge cases or if you want to extend the framework or build another framework 
on top of it, you may want to register message handlers or bindings programmatically. The #cdi MessageRouter #cdi interface
contains the following methods for regristration: #par

#cdb
function registerMessageHandler (targetInstance:Object, targetMethod:String, 
    messageType:Class = null, messageProperties:Array = null, selector:* = undefined) 
                                                                       : MessageTarget;
            
function registerMessageBinding (targetInstance:Object, targetProperty:String, 
    messageType:Class, messageProperty:String, selector:* = undefined) : MessageTarget;
    
function registerMessageInterceptor (targetInstance:Object, targetMethod:String, 
    messageType:Class = null, selector:* = undefined) : MessageTarget;
#cdb

#par The parameters correspond to the attributes of the Metadata, MXML and XML tags you saw in earlier sections of this chapter.
To get hold of the #cdi MessageRouter #cdi instance you can inject a #cdi Context #cdi instance into your class. The 
#cdi messageRouter #cdi property of a #cdi Context #cdi instance always refers to the active #cdi MessageRouter #cdi: #par

#cdb
class SomeExoticClass {

    [Inject]
    public var context:Context;
    
    [PostConstruct]
    public function init () : void {
        context.messageRouter.registerMessageHandler(this, "handleLogin", LoginMessage);    
    }
}
#cdb

#par When you place an #cdi [Inject] #cdi metadata tag on a property of type #cdi Context #cdi Parsley will always
inject the #cdi Context #cdi instance this class is managed in. #par

#par Finally you can also use the #cdi MessageRouter #cdi to dispatch messages: #par

#cdb
context.messageRouter.dispatchMessage(new LoginMessage(user, "admin"));
#cdb




