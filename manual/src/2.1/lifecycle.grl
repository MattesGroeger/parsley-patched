#sc1 lifecycle_intro Object Lifecycle #sc1

#par This chapter lists several features that go beyond the configuration features listed in previous chapters. #par


#sc2 lifecycle_factories Using Factories #sc2

#par Sometimes configuring the target object directly may not be sufficient. Maybe you want to execute some complex
logic on object creation that would be difficult to setup declaratively. In these cases you can use a factory instead.
The factory is a normal AS3 class that you can configure like any other class in Parsley, using Metadata, MXML or XML tags.
The only difference is that one method is marked as a factory method (again using Metadata, MXML or XML): #par

#cdb
class CategoryFactory {

    public var categoryName:String;
    
    [Inject]
    public var bookManager:BookManager;
    
    [Factory]
    public function createCategory () : Category {
        var books:Array = bookManager.getBooksForCategory(categoryName);
        return new Category(categoryName, books);
    }
}
#cdb

#par You can then use this factory in your configuration, for example in MXML: #par

#cdb
<mx:Object 
    xmlns:mx="http://www.adobe.com/2006/mxml"
    xmlns:model="com.bookstore.model.*">
    
    <model:BookManager/>
    
    <model:CategoryFactory id="historyCategory" categoryName="history"/>

    <model:CategoryFactory id="politicsCategory" categoryName="politics"/>

    <model:CategoryFactory id="artsCategory" categoryName="arts"/>
        
</mx:Object> 
#cdb

#par Each of the factories we defined above will get the #cdi BookManager #cdi instance injected and then produce
instances of #cdi Category #cdi. #par

#par The special thing about using factories is that under the hood Parsley actually
creates #str two #str object definitions for each factory: One for the factory itself and one for the type the
factory method produces. This means that you can also place metadata tags on the target type (in this case the
#cdi Category #cdi class) if you want the object that the factory produces to send and receive application messages
managed by Parsley for example. #par
 
#par This also means that you can use the factory #str and #str the objects it creates at injection points, although
in most cases you'll be interested in the objects produced by the factory: #par

#cdb
[Inject(id="historyCategory")]
public var historyBooks:Category;
#cdb

#par It is recommended not to use factory methods with a return type of #cdi Object #cdi like this: #par

#cdb
[Factory]
public function createInstance () : Object {
#cdb

#par It would work, Parsley would happily process this kind of factory method. But you'll lose some of
Parsley's useful capabilities, since it uses the return type of the method for producing the object
definition for the target type. If the target type is just Object, the metadata tags on the objects
this factory actually produces would not be processed, since this happens #str before #str the factory method
will be invoked for the first time. Furthermore you cannot use objects produced by such a factory
for Dependency Injection by Type, since the type can only be determined dynamically. You would then
be constrained to Injection by Id. #par

#par Of course, like with most other Parsley features, you may also declare the factory method in 
MXML or XML. This may come in handy in some edge cases, for example for a factory that has more than
one method that produces objects. In this case placing metadata tags in the class itself would not
be possible (only one #cdi [Factory] #cdi tag is allowed). #par


#sub MXML Example #sub

#cdb
<Object id="monkey" type="{ZooFactory}">
    <Factory method="createMonkey"/> 
</Object>
<Object id="polarBear" type="{ZooFactory}">
    <Factory method="createPolarBear"/> 
</Object>
#cdb
 
#sub XML Example #sub

#cdb
<object id="monkey" type="com.example.ZooFactory">
    <factory method="createMonkey"/> 
</object>
<object id="polarBear" type="com.example.ZooFactory">
    <factory method="createPolarBear"/> 
</object>
#cdb



#sc2 lifecycle_async Asynchronous Object Initialization #sc2

#par A lot of operations in the Flash Player execute asynchronously. So it might happen that you want an object
configured in the Parsley IOC Container to load some data or assets first, before the rest of the Context gets
initialized and before this asynchronously initializing object gets injected into other objects. In this cases
you can use the #cdi [AsyncInit] #cdi tag on any #cdi EventDispatcher #cdi that fires events when the initialization
is completed (or if it has failed): #par

#cdb
#hlt [AsyncInit] #hlt
public class FileLoader extends EventDispatcher {

    public var filename:String;

    #hlt [Init] #hlt
    public function init () : void {
        var loader:URLLoader = new URLLoader();
        loader.addEventListener(Event.COMPLETE, fileLoaded);
        loader.addEventListener(IOErrorEvent.IO_ERROR, handleError);
        loader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, handleError);
        loader.load(new URLRequest(filename));            
   }
   
   private function fileLoaded (event:Event) : void {
       // handle loaded file
       #hlt dispatchEvent(new Event(Event.COMPLETE)); #hlt
   }
   
   private function handleError (event:ErrorEvent) : void {
       #hlt dispatchEvent(new ErrorEvent(ErrorEvent.ERROR, false, false, event.text)); #hlt
   }
   
}
#cdb

#par In the example above the #cdi [AsyncInit] #cdi tag tells the framework that this is an asynchronously initializing
object. In the method annotated with #cdi [Init] #cdi which will be invoked after configuration and
dependency injection has been processed for that object (see #ref lifecycle_methods #ref for details) we start the
loading process. Depending on whether the loading succeeds or not we then dispatch either an #cdi Event.COMPLETE #cdi
or an #cdi ErrorEvent.ERROR #cdi. The container will listen for those two events. In case of #cdi Event.COMPLETE #cdi it
will proceed with Context initialization. In case of #cdi ErrorEvent.ERROR #cdi the whole Context initialization process
will be cancelled. #par

#sub Switching event types #sub

#par #cdi Event.COMPLETE #cdi and #cdi ErrorEvent.ERROR #cdi are the default event types to signal whether initialization
has completed or failed. They can be switched with attributes of the #cdi [AsyncInit] #cdi tag: #par

#cdb
[AsyncInit(completeEvent="myCustomCompleteEvent",errorEvent="myCustomErrorEvent")]
#cdb

#sub Initialization order #sub

#par In case you want to explicitly specify the initialization order you can do that with the order attribute: #par

#sub MXML Example #sub

#cdb
<Object id="welcomeText" type="{FileLoader}" order="1">
    <AsyncInit/>
    <Init method="init"/>
    <Property name="filename" value="welcome.txt"/>
</Object>
#cdb
 
#sub XML Example #sub

#cdb
<object id="welcomeText" type="com.example.FileLoader" order="1">
    <async-init/>
    <init method="init"/>
    <property name="filename" value="welcome.txt"/>
</object>
#cdb

#par The default value if you omit this attribute is #cdi int.MAX_VALUE #cdi so that all objects without an order attribute
will execute last and in arbitrary order. The attribute can be set to any positive or negative integer value. 
The order attribute can also be used for objects that initialize synchronously. #par



#sc2 lifecycle_methods Object Lifecycle Methods #sc2

#par If you want the Parsley Container to invoke methods on your object when it is created or when it is destroyed,
you can add the #cdi [Init] #cdi or #cdi [Destroy] #cdi metadata tags to the corresponding methods: #par

#cdb
[Init]
public function init () : void {
    [...]
}
[Destroy]
public function dispose () : void {
    [...]
}
#cdb

#par The methods marked with #cdi [Init] #cdi get invoked after the object has been instantiated and
all injections have been processed. #par

#par The methods marked with #cdi [Destroy] #cdi get invoked after the Context instance they belong to has been
destroyed with #cdi Context.destroy() #cdi or when the object was removed from the Context. 
See #ref lifecycle_methods #ref for details. #par

#par For Flex Components declared in regular MXML files and wired to the Context as described in #ref view_intro #ref
the lifecycle is different: For those objects the methods get invoked whenever the object is added to or removed from the
stage respectively. Of course the #cdi [Destroy] #cdi method additionally gets invoked if the Context the object
was wired to was destroyed. #par



#sc2 lifecycle_dynamic Dynamic Objects #sc2

#par Since version 2.1 there is a new interface #cdi DynamicContext #cdi. Such a Context allows you to dynamically
add and remove objects from the Context. In most cases this is not intended to be used by normal application code,
but you can easily build extensions on top of that functionality that require some more flexibility than the
regular Context. Internally the #cdi DynamicContext #cdi will be used for wiring views which are added and removed
from the Context depending on the time they are placed on the stage and (starting from version 2.2) for short-lived
Command objects which are only added to the Context to perform their asynchronous operation and then immediately get
removed again. #par

#par Dynamic Objects almost behave the same like regular objects. In particular this means: #par

#lst
#lse You can inject any regular object into the dynamic object. #lse
#lse The dynamic object can send and receive messages to and from any of the available scopes. #lse
#lse The dynamic object can have lifecycle methods like #cdi [Init] #cdi and #cdi [Destroy] #cdi. #lse
#lst

#par There is only one significant restriction for using dynamic objects: #par

#lst
#lse You cannot inject a dynamic object into another object. #lse
#lst

#par This restriction is natural, since dependency injection comes with validation which would not be possible
if the set of objects available for injection could change at any point in time. This is no real limitation anyway
since you can get hold of these dynamic objects through their lifecycle methods, in case you want to get notified
whenever an object of a particular type enters the Context (or any scope of Contexts). #par

#par You can create a dynamic Context from a regular one: #par

#cdb
var dynamicContext:DynamicContext = context.createDynamicContext();
#cdb

#par This way the dynamic Context is connected to the regular one and all objects living in that Context or
one of its parents can be injected into the dynamic objects. You can then simply add any object to that Context: #par

#cdb
var instance:Object = ...;
var dynamicObject:DynamicObject = dynamicContext.addObject(instance);
#cdb

#par In this case an #cdi ObjectDefinition #cdi will be created for the existing instance and metadata will
be processed for the type of that instance, performing any required dependency injection, message receiver
registration or lifecycle method invocation. #par

#par The object can be removed from the Context at any point in time: #par

#cdb
dynamicObject.remove();
#cdb

#par At this point the method marked with #cdi [Destroy] #cdi will be invoked on that object (if existent)
and any message receiver registrations will be terminated. The object is then fully removed from the Context. #par

#par For building extensions which talk to a #cdi DynamicContext #cdi instance from within a #cdi ObjectDefinitionDecorator #cdi
or #cdi ObjectDefinitionFactory #cdi implementation there are two interesting variants of the #cdi addObject #cdi method
shown above. First it is possible to pass an additional #cdi ObjectDefinition #cdi to the method: #par

#cdb
var definition:ObjectDefinition = ...;
var instance:Object = ...;
var dynamicObject:DynamicObject = dynamicContext.addObject(instance, definition);
#cdb

#par In this case the definition will not be created by the dynamic Context like in the preceding example. Instead
the specified definition will be used. In version 2.2 this mechanism will be used internally to support the new
option to configure dynamically wired views in MXML. An existing instance will have to be configured by an
#cdi ObjectDefinition #cdi then which has been created elsewhere. #par

#par Finally you can also just pass a definition to the dynamic Context and it will create a new instance 
based on that definition: #par

#cdb
var definition:ObjectDefinition = ...;
var dynamicObject:DynamicObject = dynamicContext.addDefinition(definition);
#cdb

#par The instance created by the Context can then be accessed like this: #par

#cdb
var instance:Object = dynamicObject.instance;
#cdb

#par In all these different use cases removal of the object happens in the way already demonstrated: #par

#cdb
dynamicObject.remove();
#cdb






 






